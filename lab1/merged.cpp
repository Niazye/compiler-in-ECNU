/*
 * Generated by C++ Merger Tool
 * Merge Time: Tue Dec 23 08:23:41 CST 2025
 * Source Files: DFA.h, LexAnalysis.h, keys_patterns.h, DFA.cpp
 * Total Files Merged: 4
 */

// === 合并的文件开始 ===

#include <chrono>
#include <cctype>
#include <sstream>
#include <fstream>
#include <cstring>
#include <cstdio>
#include <set>
#include <unordered_set>
#include <unordered_map>
#include <map>
#include <queue>
#include <cassert>
#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <memory>
#include <list>
// === 系统头文件 ===

// ============================================================
// File: DFA.h
// Path: DFA.h
// ============================================================

#ifndef DFA_H
#define DFA_H

#include <list>
#include <memory>
#include <vector>
#include <string>
#include <regex>
#include <iostream>
#include <cassert>
#include <queue>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>

enum RE_operator    // 操作符类型
{
    UNION,
    CONCAT,
    KLEENE_STAR,
    PLUS,
    LEFT_BRACKET,
    RIGHT_BRACKET,
    TERMINAL,
};
enum RE_char_type   // 操作符 or 字符
{
    OPTR,
    RECHAR
};

struct nfa_state;
struct dfa_state;
class RE;
class RE_tree;
class NFA;
class DFA;

typedef std::pair<char, std::weak_ptr<nfa_state>> nfa_transfer_t;
typedef std::pair<char, std::weak_ptr<dfa_state>> dfa_transfer_t;
typedef std::set<std::shared_ptr<nfa_state>> nfa_state_set_t;

void trim_inplace(std::string& str);
bool pattern_cmp(const std::pair<std::string, std::string>& a, const std::pair<std::string, std::string>& b);
bool drop_global_bracket(std::string& str, std::vector<bool>& op_pattern);

struct nfa_state
{
    bool is_final = false;
    std::multimap<char, std::weak_ptr<nfa_state>> transfers;
};
struct dfa_state
{
    bool is_final = false;
    std::map<char, std::weak_ptr<dfa_state>> transfers;
};

class RE_tree
{
    RE_operator op;
    char value = 0;
    std::unique_ptr<RE_tree> left;
    std::unique_ptr<RE_tree> right;
    friend class NFA;
    std::unordered_set<char> terminal_chars;
public:
    RE_tree(RE_operator oper, char val = 0, std::unique_ptr<RE_tree> l = nullptr, std::unique_ptr<RE_tree> r = nullptr);
    RE_tree(RE pattern_obj);
    ~RE_tree();
    operator bool() const;
};

class RE
{
    std::string pattern;
    std::vector<bool> op_pattern;
    std::vector<std::pair<std::string, std::string>> defination_patterns;
    std::unordered_set<char> terminal_chars;
    std::pair<std::string, std::vector<bool>> getPattern();
    friend class RE_tree;
public:

    RE(std::string pattern, std::vector<bool> op_pattern);
    RE(std::string pattern = "");
    ~RE();
    void add_pattern_line(std::string input_pattern);
    void merge_patterns();
    void parse_pattern();
    void print_pattern();
};

class NFA
{
    std::shared_ptr<nfa_state> start_state;
    std::shared_ptr<nfa_state> final_state;
    std::unordered_set<char> terminal_chars;
    std::vector<std::shared_ptr<nfa_state>> owned_states; // owns all states to keep weak_ptr targets alive
    static void swap(NFA& first, NFA& second);
    friend class DFA;
public:
    NFA(const RE_tree& re_tree);
    ~NFA();
    NFA(const NFA& other);
    NFA(const char terminal);
    NFA& operator=(const NFA& other);
    bool union_other(const NFA& other);
    bool concat_other(const NFA& other);
    bool kleene_star();
    bool plus();
};

class DFA
{
    std::shared_ptr<dfa_state> start_state;
    std::unordered_set<char> terminal_chars;
    std::vector<std::shared_ptr<dfa_state>> owned_states; // owns DFA states
public:
    ~DFA();
    DFA(const NFA& nfa);
    nfa_state_set_t move(const nfa_state_set_t& states, char input);
    nfa_state_set_t epsilon_closure(const nfa_state_set_t& states);
    void minimize();
    bool all_match(const std::string& input, size_t start_pos = 0);
    size_t longest_match(const std::string& input, size_t start_pos = 0);
};

#endif

// ============================================================
// File: LexAnalysis.h
// Path: LexAnalysis.h
// ============================================================

// C语言词法分析器
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <cctype>
#include <chrono>

// [Already included] #include "DFA.h"
// Include start: keys_patterns.h

// ============================================================
// File: keys_patterns.h
// Path: keys_patterns.h
// ============================================================

#ifndef KEYS_PATTERNS_H
#define KEYS_PATTERNS_H

#include <string>
    std::string CONSTANT_PATTERN =
    R"delimiter(
    constant    -> inte | frac

    inte        -> (bin_inte | oct_inte | dec_inte | hex_inte) opt_inte_suf
    bin_inte    -> 0(b|B) bin_digit+
    oct_inte    -> 0 oct_digit+
    dec_inte    -> (dec_digit_no_zero dec_digit*) | 0
    hex_inte    -> 0(x|X) hex_digit+
    opt_inte_suf     -> \0 | unsigned_suf | long_suf | (unsigned_suf long_suf) | (long_suf unsigned_suf)
    
    frac        -> (dec_frac | hex_frac) opt_frac_suf
    dec_frac    -> (dec_point dec_opt_exp) | (dec_digit+ dec_exp)
    hex_frac    -> 0(x|X) hex_base hex_opt_exp
    dec_point    -> (dec_digit+ \. dec_digit*) | (dec_digit* \. dec_digit+)
    dec_opt_exp -> \0 | ((e | E) opt_sign dec_digit)
    dec_exp     -> (e | E) opt_sign dec_digit+
    hex_base    -> (hex_digit+ \. hex_digit*) | (hex_digit* \. hex_digit+) | (hex_digit+)
    hex_opt_exp -> \0 | ((p | P) opt_sign hex_digit)
    opt_frac_suf    -> \0 | float_suf | long_double_suf
    
    unsigned_suf        -> u | U
    long_suf    -> l | L | ll | LL
    float_suf   -> f | F
    long_double_suf -> l | L
    opt_sign    -> \0 | \+ | -
    bin_digit   -> 0 | 1
    oct_digit   -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
    dec_digit   -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    dec_digit_no_zero   -> 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    hex_digit   -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F
    )delimiter";

    std::string IDENTIFIER_PATTERN =
    R"delimiter(
    identifier    -> (letter | _ ) (letter | digit | _ )*
    letter      -> lowercase | uppercase
    lowercase -> a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
    uppercase -> A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
    digit       -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    )delimiter";

    std::string SIMPLE_CONSTANT_PATTERN =
    R"delimiter(const -> (0|1|2|3|4|5|6|7|8|9)+)delimiter";

    std::string EXPAND_CONSTANT_PATTERN =
    R"delimiter(const -> (((0.(b|B).(0|1)+)|(0.(0|1|2|3|4|5|6|7)+)|(((1|2|3|4|5|6|7|8|9).(0|1|2|3|4|5|6|7|8|9)*)|0)|(0.(x|X).(0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)+)).(\0|(u|U)|(l|L|l.l|L.L)|((u|U).(l|L|l.l|L.L))|((l|L|l.l|L.L).(u|U))))|(((((((0|1|2|3|4|5|6|7|8|9)+.\..(0|1|2|3|4|5|6|7|8|9)*)|((0|1|2|3|4|5|6|7|8|9)*.\..(0|1|2|3|4|5|6|7|8|9)+)).(\0|((e|E).(\0|\+|-).(0|1|2|3|4|5|6|7|8|9))))|((0|1|2|3|4|5|6|7|8|9)+.((e|E).(\0|\+|-).(0|1|2|3|4|5|6|7|8|9)+)))|(0.(x|X).(((0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)+.\..(0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)*)|((0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)*.\..(0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)+)|((0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F)+)).(\0|((p|P).(\0|\+|-).(0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|A|B|C|D|E|F))))).(\0|(f|F)|(l|L))))delimiter";
    std::string EXPAND_IDENTIFIER_PATTERN =
    R"delimiter(id -> (((a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z)|(A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z))|_).(((a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z)|(A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z))|(0|1|2|3|4|5|6|7|8|9)|_)*)delimiter";
#endif // KEYS_PATTERNS_H
// Include end: keys_patterns.h
using namespace std;

enum TokenType
{
    KEYWORD,    // 关键字
    IDENTIFIER, // 标识符
    CONSTANT,   // 常数
    STRING,     // 字符串
    OPERATOR,   // 运算符
    COMMENT,    // 注释
    UNKNOWN
};

typedef TokenType token_type_id;
typedef pair<token_type_id, std::string> token_t;
typedef pair<int, string> resolved_token_t;

/* 不要修改这个标准输入函数 */
void read_prog(string &prog)
{
    char c;
    while (scanf("%c", &c) != EOF)
    {
        prog += c;
    }
}

void print_single_token(const resolved_token_t token, int index);

DFA constant_dfa = DFA(NFA(RE(SIMPLE_CONSTANT_PATTERN)));
DFA identifier_dfa = DFA(NFA(RE(EXPAND_IDENTIFIER_PATTERN)));

class LexAnalyser
{
private:
    map<string, int> keys_map; // 关键字 -> 序号
    vector<token_t> unresolved_tokens;
    vector<resolved_token_t> resolved_tokens;
    string prog;
    size_t pos;
    bool is_at_string_token;
    TokenType current_type;
    /*
     * 获取下一个词法单元，并通过引用存储在传入的 token 参数中
     * 若此时已经到达末尾，直接返回 false 停止外部的 while 循环
    */
    bool get_next_token(token_t &token)
    {
        if(!is_at_string_token)
        {
            // 跳过空白字符
            while (pos < prog.length() && isspace(prog[pos]))
                pos++;
        }
        if (pos >= prog.length())
            return 0;

        if (prog[pos] == '\"') {
            is_at_string_token = !is_at_string_token;
            token = {OPERATOR, "\""};
            pos++;
            return 1;
        }

        if (is_at_string_token)
        {
            token.first = STRING;
            token = handle_string_literal();
            if (token.second != "")
                return 1;
        }

        if (isdigit(prog[pos]) || (prog[pos] == '.')) {
            current_type = CONSTANT;
            token = handle_constant();
            if (token.second != "")
                return 1;
        }

        if (isalpha(prog[pos]) || prog[pos] == '_') {
            token = handle_identifier_or_keyword();
            current_type = token.first;
            if (token.second != "")
                return 1;
        }

        if (pos + 1 < prog.length() && prog[pos] == '/' && prog[pos + 1] == '/') {
            current_type = COMMENT;
            token = handle_comment(0);
            if (token.second != "")
                return 1;
        }

        if (pos + 1 < prog.length() && prog[pos] == '/' && prog[pos + 1] == '*') {
            current_type = COMMENT;
            token = handle_comment(1);
            if (token.second != "")
                return 1;
        }

        current_type = OPERATOR;
        token = handle_operator();
        return token.second != "";
    }

    token_t handle_constant()
    {
        const size_t start_pos = pos;
        size_t match_length = constant_dfa.longest_match(prog, pos);
        token_t res;
        res.first = CONSTANT;
        res.second = prog.substr(start_pos, match_length);
        if (constant_dfa.all_match(res.second))
        {
            pos += match_length;
        }
        return res;
    }

    token_t handle_identifier_or_keyword()
    {
        const size_t start_pos = pos;
        size_t match_length = identifier_dfa.longest_match(prog, pos);
        token_t res;
        res.second = prog.substr(start_pos, match_length);
        if (keys_map.find(res.second) != keys_map.end()) {
            res.first = KEYWORD;
        } else {
            res.first = IDENTIFIER;
        }
        pos += match_length;
        return res;
    }

    token_t handle_comment(int type)
    {
        token_t res;
        if (type == 0) {
            // 单行注释
            size_t start_pos = pos;
            pos += 2; // 跳过 "//"
            while (pos < prog.length() && prog[pos] != '\n') {
                pos++;
            }
            res.first = COMMENT;
            res.second = prog.substr(start_pos, pos - start_pos);
        } else {
            // 多行注释
            size_t start_pos = pos;
            pos += 2; // 跳过 "/*"
            while (pos + 1 < prog.length() && !(prog[pos] == '*' && prog[pos + 1] == '/')) {
                pos++;
            }
            if (pos + 1 < prog.length()) {
                pos += 2; // 跳过 "*/"
            }
            res.first = COMMENT;
            res.second = prog.substr(start_pos, pos - start_pos);
        }
        return res;
    }

    token_t handle_string_literal() {
        token_t res;
        
        for (; pos < prog.length(); pos++) {
            if (prog[pos] == '\\' && pos + 1 < prog.length()) {
                ++pos; // 跳过反斜杠
                switch (prog[pos]) {
                    case 'n': res.second.push_back('\n'); break;
                    case 'r': res.second.push_back('\r'); break;
                    case 't': res.second.push_back('\t'); break;
                    case 'v': res.second.push_back('\v'); break;
                    case 'b': res.second.push_back('\b'); break;
                    case 'f': res.second.push_back('\f'); break;
                    case 'a': res.second.push_back('\a'); break;
                    case '\\': res.second.push_back('\\'); break;
                    case '\'': res.second.push_back('\''); break;
                    case '\"': res.second.push_back('\"'); break;
                    case '?': res.second.push_back('?'); break;
                    case '0': res.second.push_back('\0'); break;
                    default:
                        // 未知转义，保留原样
                        res.second.push_back('\\');
                        res.second.push_back(prog[pos]);
                        break;
                }
            } else if(prog[pos] == '\"') {
                break;
            } else {
                res.second.push_back(prog[pos]);
            }
        }

        res.first = STRING;
        return res;
    }

    token_t handle_operator()
    {
        token_t res;
        for (auto ele = keys_map.rbegin(); ele != keys_map.rend(); ele++)
        {
            auto pattern = ele->first;
            if (pos + pattern.length() > prog.length()) continue;
            bool match = true;
            for (size_t i = 0; i < pattern.length(); ++i) {
                if (prog[pos + i] != pattern[i]) {
                    match = false;
                    break;
                }
            }
            if (match)
            {
                pos += pattern.length();
                res = {OPERATOR, pattern};
                break;
            }
        }
        return res;
    }

    void resolve_tokens()
    {
        for (const auto &token: unresolved_tokens)
        {
            switch (token.first)
            {
                case IDENTIFIER:
                    resolved_tokens.push_back({keys_map["标识符"], token.second}); // 关键字
                    break;
                case CONSTANT:
                    resolved_tokens.push_back({keys_map["常数"], token.second}); // 常数
                    break;
                case STRING:
                    resolved_tokens.push_back({keys_map["标识符"], token.second}); // 字符串
                    break;
                case COMMENT:
                    resolved_tokens.push_back({keys_map["/*注释*/"], token.second}); // 注释
                    break;
                default:
                    resolved_tokens.push_back({keys_map[token.second], token.second}); // 关键字或运算符
                    break;
            }
        }
    }
public:
    LexAnalyser(const string &input_prog) : prog(input_prog), pos(0)
    {
        // 初始化关键字和符号映射表
        ifstream file("c_keys.txt");
        string line;
        while (getline(file, line))
        {
            istringstream iss(line);
            int key;
            string value;
            if (iss >> value >> key)
            {
                keys_map[value] = key;
            }
        }
        file.close();
        is_at_string_token = 0;
        unresolved_tokens.clear();
        resolved_tokens.clear();
    }

    vector<resolved_token_t> analyze()
    {
        token_t token;
        while(get_next_token(token))
        {
            if (token.second != "")
                unresolved_tokens.push_back(token);
        }
        resolve_tokens();
        return resolved_tokens;
    }

    void print_res()
    {
        for (size_t i = 0; i < resolved_tokens.size(); i++)
        {
            print_single_token(resolved_tokens[i], i + 1);
        }
    }
};

void print_single_token(const resolved_token_t token, int index)
{
    cout << index << ": <" << token.second << "," << token.first << ">" << endl;
}

void Analysis()
{
    freopen("input.txt", "r", stdin);
    string prog;
    read_prog(prog);
    const auto start_time = chrono::steady_clock::now();
    /********* Begin *********/

    LexAnalyser lexer(prog);
    lexer.analyze();

    lexer.print_res();
    const auto end_time = chrono::steady_clock::now();
    const auto elapsed_us = chrono::duration_cast<chrono::microseconds>(end_time - start_time).count();
    cout << "Analysis elapsed: " << elapsed_us << " us" << endl;
    /********* End *********/
}

// ============================================================
// File: DFA.cpp
// Path: DFA.cpp
// ============================================================

// [Already included] #include "DFA.h"

void trim_inplace(std::string& str) {
    size_t start = str.find_first_not_of(" \t\n\r");
    if (start == std::string::npos) {
        str.clear();
        return;
    }
    size_t end = str.find_last_not_of(" \t\n\r");
    str = str.substr(start, end - start + 1);
}
bool pattern_cmp(const std::pair<std::string, std::string>& a, const std::pair<std::string, std::string>& b)
{
    return a.first.length() > b.first.length();
}
bool drop_global_bracket(std::string& str, std::vector<bool>& op_pattern)
{
    if (str.front() == LEFT_BRACKET && str.back() == RIGHT_BRACKET && op_pattern.front() == OPTR && op_pattern.back() == OPTR)
    {
        int bracket_count = 0;
        for (size_t i = 0; i < str.length(); i++)
        {
            if (str[i] == LEFT_BRACKET && op_pattern[i] == OPTR)
                bracket_count++;
            else if (str[i] == RIGHT_BRACKET && op_pattern[i] == OPTR)
                bracket_count--;
            if (bracket_count == 0 && i != str.length() - 1)
                return 0;
        }
        str = str.substr(1, str.length() - 2);
        op_pattern.erase(op_pattern.begin());
        op_pattern.pop_back();
        return 1;
    }
    return 0;
}
RE::RE(std::string pattern, std::vector<bool> op_pattern)
{
    this -> pattern = pattern;
    this -> op_pattern = op_pattern;
}
RE::RE(std::string pattern)
{
    std::istringstream pattern_stream(pattern);
    std::string line;
    while (std::getline(pattern_stream, line))
    {
        if (line.empty()) continue;
        add_pattern_line(line);
    }
    merge_patterns();
    parse_pattern();
}
RE::~RE() {}
std::pair<std::string, std::vector<bool>> RE::getPattern()
{
    return {pattern, op_pattern};
}
void RE::add_pattern_line(std::string input_pattern)
{
    std::string def_name, def_pattern;
    trim_inplace(input_pattern);
    if(input_pattern.empty())
        return;
    def_name = input_pattern.substr(0, input_pattern.find("->"));
    def_pattern = input_pattern.substr(input_pattern.find("->") + 2);
    trim_inplace(def_name);
    trim_inplace(def_pattern);
    defination_patterns.push_back({def_name, def_pattern});
}
void RE::merge_patterns()
{
    if (defination_patterns.empty() || defination_patterns.size() == 1)
        return;
    std::sort(defination_patterns.begin() + 1, defination_patterns.end(), pattern_cmp);
    for (size_t i = 1; i < defination_patterns.size(); i++)
    {
        for (size_t j = 0; j < defination_patterns.size(); j++)
        {
            if (j == i)
                continue;
            defination_patterns[j].second = std::regex_replace(
                defination_patterns[j].second,
                std::regex(defination_patterns[i].first),
                "(" + defination_patterns[i].second + ")");
        }
    }
    defination_patterns.resize(1);
}
void RE::parse_pattern()
{
    if (defination_patterns.empty())
        return;
    std::string str_pattern = defination_patterns[0].second;
    for (auto itr = str_pattern.begin(); itr != str_pattern.end(); itr++)
    {
        if (isspace(*itr))
            continue;
        char to_push;
        RE_char_type to_type;
        if (*itr == '\\')
        {
            switch (*(itr + 1))
            {
            case 'n':
                to_push = '\n';
                to_type = RECHAR;
                itr++;
                break;
            case 't':
                to_push = '\t';
                to_type = RECHAR;
                itr++;
                break;
            case 'r':
                to_push = '\r';
                to_type = RECHAR;
                itr++;
                break;
            case '+':
                to_push = '+';
                to_type = RECHAR;
                itr++;
                break;
            case '*':
                to_push = '*';
                to_type = RECHAR;
                itr++;
                break;
            case '|':
                to_push = '|';
                to_type = RECHAR;
                itr++;
                break;
            case '(':
                to_push = '(';
                to_type = RECHAR;
                itr++;
                break;
            case ')':
                to_push = ')';
                to_type = RECHAR;
                itr++;
                break;
            case '.':
                to_push = '.';
                to_type = RECHAR;
                itr++;
                break;
            case '0':
                to_push = '\0';
                to_type = RECHAR;
                itr++;
                break;
            case '\\':
                to_push = '\\';
                to_type = RECHAR;
                itr++;
                break;
            default:
                to_push = *itr;
                to_type = RECHAR;
                break;
            }
        }
        else
        {
            switch (*itr)
            {
            case '+':
                to_push = PLUS;
                to_type = OPTR;
                break;
            case '*':
                to_push = KLEENE_STAR;
                to_type = OPTR;
                break;
            case '|':
                to_push = UNION;
                to_type = OPTR;
                break;
            case '(':
                to_push = LEFT_BRACKET;
                to_type = OPTR;
                break;
            case ')':
                to_push = RIGHT_BRACKET;
                to_type = OPTR;
                break;
            case '.':
                to_push = CONCAT;
                to_type = OPTR;
                break;
            default:
                to_push = *itr;
                to_type = RECHAR;
                break;
            }
        }
        if(!pattern.empty())
        {
            if ((op_pattern.back() == RECHAR                                      && to_type == RECHAR                           ) ||
                (op_pattern.back() == RECHAR                                      && to_type == OPTR && to_push == LEFT_BRACKET) ||  
                (op_pattern.back() == OPTR && pattern.back() == RIGHT_BRACKET   && to_type == RECHAR                           ) ||
                (op_pattern.back() == OPTR && pattern.back() == RIGHT_BRACKET   && to_type == OPTR && to_push == LEFT_BRACKET) ||
                (op_pattern.back() == OPTR && pattern.back() == KLEENE_STAR     && to_type == RECHAR                           ) ||
                (op_pattern.back() == OPTR && pattern.back() == PLUS            && to_type == RECHAR                           ) ||
                (op_pattern.back() == OPTR && pattern.back() == KLEENE_STAR     && to_type == OPTR && to_push == LEFT_BRACKET) ||
                (op_pattern.back() == OPTR && pattern.back() == PLUS            && to_type == OPTR && to_push == LEFT_BRACKET))
            {
                op_pattern.push_back(OPTR);
                pattern.push_back(CONCAT);
            }
        }
        op_pattern.push_back(to_type);
        pattern.push_back(to_push);
        if (to_type == RECHAR && to_push != '\0')
            terminal_chars.insert(to_push);
    }
}
void RE::print_pattern()
{
    std::cout << defination_patterns[0].first << " -> " << defination_patterns[0].second << std::endl;
}

RE_tree::RE_tree(RE_operator oper, char val, std::unique_ptr<RE_tree> l, std::unique_ptr<RE_tree> r)
{
    op = oper;
    value = val;
    left = std::move(l);
    right = std::move(r);
}
RE_tree::RE_tree(RE pattern_obj)
{
    this -> terminal_chars = pattern_obj.terminal_chars;
    auto pattern = pattern_obj.getPattern().first;
    auto op_pattern = pattern_obj.getPattern().second;
    assert(pattern.length() != 0);
    while(drop_global_bracket(pattern, op_pattern));
    int bracket_count = 0;
    if (pattern.length() == 1 && op_pattern[0] == RECHAR)
    {
        op = TERMINAL;
        value = pattern[0];
        left = nullptr;
        right = nullptr;
        return;
    }
    for (size_t i = 0; i < pattern.length(); i++)
    {
        if (pattern[i] == LEFT_BRACKET && op_pattern[i] == OPTR)
            bracket_count++;
        else if (pattern[i] == RIGHT_BRACKET && op_pattern[i] == OPTR)
            bracket_count--;
        else if (bracket_count == 0)
        {
            if (pattern[i] == UNION && op_pattern[i] == OPTR)
            {
                op = UNION;
                left = std::make_unique<RE_tree>(RE(pattern.substr(0, i), std::vector<bool>(op_pattern.begin(), op_pattern.begin() + i)));
                right = std::make_unique<RE_tree>(RE(pattern.substr(i + 1), std::vector<bool>(op_pattern.begin() + i + 1, op_pattern.end())));
            }
            else if (pattern[i] == KLEENE_STAR && op_pattern[i] == OPTR && i + 1 == pattern.length())
            {
                op = KLEENE_STAR;
                left = std::make_unique<RE_tree>(RE(pattern.substr(0, i), std::vector<bool>(op_pattern.begin(), op_pattern.begin() + i)));
                right = nullptr;
            }
            else if (pattern[i] == PLUS && op_pattern[i] == OPTR && i + 1 == pattern.length())
            {
                op = PLUS;
                left = std::make_unique<RE_tree>(RE(pattern.substr(0, i), std::vector<bool>(op_pattern.begin(), op_pattern.begin() + i)));
                right = nullptr;
            }
            else if (pattern[i] == CONCAT && op_pattern[i] == OPTR)
            {
                op = CONCAT;
                left = std::make_unique<RE_tree>(RE(pattern.substr(0, i), std::vector<bool>(op_pattern.begin(), op_pattern.begin() + i)));
                right = std::make_unique<RE_tree>(RE(pattern.substr(i + 1), std::vector<bool>(op_pattern.begin() + i + 1, op_pattern.end())));
            }
            else
            {
                continue;
            }
            return;
        }
    }

}
RE_tree::operator bool() const 
{
    if(op == TERMINAL)
        return 1;
    else if(op == KLEENE_STAR || op == PLUS)
        return left != nullptr;
    else
        return left != nullptr && right != nullptr; 
}
RE_tree::~RE_tree()
{
}

NFA::NFA(const RE_tree& re_tree)
{
    assert(re_tree);
    std::unique_ptr<NFA> left, right;
    switch (re_tree.op)
    {
        case TERMINAL:
            *this = NFA(re_tree.value);
            break;
        case UNION:
            *this = NFA(*re_tree.left);
            this -> union_other(NFA(*re_tree.right));
            break;
        case CONCAT:
            *this = NFA(*re_tree.left);
            this -> concat_other(NFA(*re_tree.right));
            break;
        case KLEENE_STAR:
            *this = NFA(*re_tree.left);
            this -> kleene_star();
            break;
        case PLUS:
            *this = NFA(*re_tree.left);
            this -> plus();
            break;
        default:
            break;
    }

    this -> terminal_chars = re_tree.terminal_chars;
}
NFA::NFA(const char terminal)
{
    start_state = std::make_shared<nfa_state>();
    owned_states.push_back(start_state);

    auto final_ptr = std::make_shared<nfa_state>();
    owned_states.push_back(final_ptr);

    start_state -> is_final = false;
    start_state -> transfers.insert({terminal, final_ptr});
    final_state = final_ptr;
    final_state -> is_final = true;

    this -> terminal_chars.insert(terminal);
}
bool NFA::union_other(const NFA& other)
{
    auto copyed_other = NFA(other);
    std::shared_ptr<nfa_state> new_start_state = std::make_shared<nfa_state>(), new_final_state = std::make_shared<nfa_state>();
    owned_states.push_back(new_start_state);
    owned_states.push_back(new_final_state);
    owned_states.insert(owned_states.end(), copyed_other.owned_states.begin(), copyed_other.owned_states.end());
    new_start_state -> is_final = 0;
    new_final_state -> is_final = 1;
    new_start_state -> transfers.insert({'\0', this -> start_state});
    new_start_state -> transfers.insert({'\0', copyed_other.start_state});
    this -> final_state -> is_final = 0;
    this -> final_state -> transfers.insert({'\0', new_final_state});
    copyed_other.final_state -> is_final = 0;
    copyed_other.final_state -> transfers.insert({'\0', new_final_state});
    this -> start_state = new_start_state;
    this -> final_state = new_final_state;

    this -> terminal_chars.insert(copyed_other.terminal_chars.begin(), copyed_other.terminal_chars.end());
    return true;
}
bool NFA::concat_other(const NFA& other)
{
    auto copyed_other = NFA(other);
    owned_states.insert(owned_states.end(), copyed_other.owned_states.begin(), copyed_other.owned_states.end());
    this -> final_state -> is_final = 0;
    this -> final_state -> transfers.insert({'\0', copyed_other.start_state});
    this -> final_state = copyed_other.final_state;

    this -> terminal_chars.insert(copyed_other.terminal_chars.begin(), copyed_other.terminal_chars.end());
    return true;
}
bool NFA::kleene_star()
{
    auto new_start_state = std::make_shared<nfa_state>(), new_final_state = std::make_shared<nfa_state>();
    owned_states.push_back(new_start_state);
    owned_states.push_back(new_final_state);
    new_start_state -> is_final = 0;
    new_final_state -> is_final = 1;
    new_start_state -> transfers.insert({'\0', this -> start_state});
    new_start_state -> transfers.insert({'\0', new_final_state});
    this -> final_state -> is_final = 0;
    this -> final_state -> transfers.insert({'\0', this -> start_state});
    this -> final_state -> transfers.insert({'\0', new_final_state});
    this -> start_state = new_start_state;
    this -> final_state = new_final_state;
    return true;
}
bool NFA::plus()
{
    auto other = NFA(*this);
    kleene_star();
    concat_other(other);
    return true;
}
NFA::~NFA()
{
}
NFA::NFA(const NFA& other)
{
    std::queue<std::shared_ptr<nfa_state>> to_visit;
    std::unordered_map<std::shared_ptr<nfa_state>, std::shared_ptr<nfa_state>> copyed_state_map;

    std::shared_ptr<nfa_state> new_start_state = std::make_shared<nfa_state>();
    owned_states.push_back(new_start_state);
    new_start_state -> is_final = other.start_state -> is_final;
    copyed_state_map[other.start_state] = new_start_state;
    for (auto& transfer: other.start_state -> transfers)
    {
        auto target = transfer.second.lock();
        if (!target) continue;
        std::shared_ptr<nfa_state> new_transfer_state = std::make_shared<nfa_state>();
        owned_states.push_back(new_transfer_state);
        copyed_state_map[target] = new_transfer_state;
        new_start_state -> transfers.insert({transfer.first, new_transfer_state});
        to_visit.push(target);
        new_transfer_state -> is_final = target -> is_final;
    }

    while (!to_visit.empty()) 
    {
        auto cur_old_state = to_visit.front();
        to_visit.pop();

        auto copyed_cur_state = copyed_state_map[cur_old_state];
        copyed_cur_state -> is_final = cur_old_state -> is_final;
        for (auto& transfer: cur_old_state -> transfers)
        {
            auto target = transfer.second.lock();
            if (!target) continue;
            if (copyed_state_map.find(target) == copyed_state_map.end())
            {
                copyed_state_map[target] = std::make_shared<nfa_state>();
                owned_states.push_back(copyed_state_map[target]);
                to_visit.push(target);
            }
            auto &new_transdef_state = copyed_state_map[target];
            copyed_cur_state -> transfers.insert({transfer.first, new_transdef_state});
            new_transdef_state -> is_final = target -> is_final;            
        }
    }
    this -> start_state = new_start_state;
    this -> final_state = copyed_state_map[other.final_state];

    this -> terminal_chars = other.terminal_chars;
}
void NFA::swap(NFA& first, NFA& second)
{
    using std::swap;
    swap(first.start_state, second.start_state);
    swap(first.final_state, second.final_state);
    swap(first.terminal_chars, second.terminal_chars);
    swap(first.owned_states, second.owned_states);
}
NFA& NFA::operator=(const NFA& other)
{
    NFA copyed_other(other);
    swap(*this, copyed_other);
    return *this;
}

DFA::DFA(const NFA& nfa)
{
    this -> terminal_chars.insert(nfa.terminal_chars.begin(), nfa.terminal_chars.end());
    std::set<std::shared_ptr<nfa_state>> closure_states;
    std::map<std::set<std::shared_ptr<nfa_state>>, std::shared_ptr<dfa_state>> old2new_map;
    std::queue<std::set<std::shared_ptr<nfa_state>>> unmarked_old_states;
    unmarked_old_states.push(epsilon_closure({nfa.start_state}));
    auto first_state = std::make_shared<dfa_state>();
    owned_states.push_back(first_state);
    old2new_map[unmarked_old_states.front()] = first_state;
    this -> start_state = old2new_map[unmarked_old_states.front()];
    while(!unmarked_old_states.empty())
    {
        auto cur = unmarked_old_states.front();
        unmarked_old_states.pop();
        for (const auto& ter_char: this -> terminal_chars)
        {
            auto temp_states = epsilon_closure(move(cur, ter_char));
            if (temp_states.empty())
                continue;
            if (old2new_map.find(temp_states) == old2new_map.end())
            {
                unmarked_old_states.push(temp_states);
                auto new_state_ptr = std::make_shared<dfa_state>();
                owned_states.push_back(new_state_ptr);
                old2new_map[temp_states] = new_state_ptr;
            }
            auto &new_state = old2new_map[temp_states];
            old2new_map[cur] -> transfers.insert({ter_char, new_state});
        }
    }
    for (const auto& pair: old2new_map)
    {
        auto &old_states = pair.first;
        auto &new_state = pair.second;
        for (const auto& st: old_states)
        {
            if (st -> is_final)
            {
                new_state -> is_final = 1;
                break;
            }
        }
    }
}
nfa_state_set_t DFA::move(const nfa_state_set_t& states, char input)
{
    nfa_state_set_t result;
    for (const auto& st: states)
    {
        auto valid_transfers = st -> transfers.equal_range(input);
        for (auto itr = valid_transfers.first; itr != valid_transfers.second; itr++)
        {
            auto target = itr -> second.lock();
            if (target)
            {
                result.insert(target);
            }
        }
    }
    return result;
}
nfa_state_set_t DFA::epsilon_closure(const nfa_state_set_t& states)
{
    nfa_state_set_t result = states;
    std::queue<std::shared_ptr<nfa_state>> q;
    for (const auto& st: states)
    {
        q.push(st);
    }
    while (!q.empty())
    {
        auto cur = q.front();
        q.pop();
        auto valid_transfers = cur -> transfers.equal_range('\0');
        for (auto itr = valid_transfers.first; itr != valid_transfers.second; itr++)
        {
            auto target = itr -> second.lock();
            if (target && result.find(target) == result.end())
            {
                result.insert(target);
                q.push(target);
            }
        }
    }
    return result;
}
size_t DFA::longest_match(const std::string& input, size_t start_pos)
{
    auto current_states = start_state;
    size_t matched_length = 0;
    size_t last_final_pos = start_pos;
    for (size_t i = start_pos; i < input.length(); i++)
    {
        bool transitioned = false;
        auto valid_transfers = current_states -> transfers.equal_range(input[i]);
        if (valid_transfers.first == valid_transfers.second)
            break;
        for (auto transfer = valid_transfers.first; transfer != valid_transfers.second; transfer++)
        {
            auto target = transfer -> second.lock();
            if (target)
            {
                current_states = target;
                transitioned = true;
                matched_length++;
                if (current_states -> is_final)
                {
                    last_final_pos = start_pos + matched_length;
                }
                break;
            }
        }

        if (!transitioned)
            break;
    }

    return last_final_pos - start_pos;
}
bool DFA::all_match(const std::string& input, size_t start_pos)
{
    auto current_states = start_state;
    bool matched = 0;

    for (size_t i = start_pos; i < input.length(); i++)
    {
        auto valid_transfers = current_states -> transfers.equal_range(input[i]);
        matched = 0;
        for (auto transfer = valid_transfers.first; transfer != valid_transfers.second; transfer++)
        {
            auto target = transfer -> second.lock();
            if (target)
            {
                current_states = target;
                matched = 1;
                break;
            }
        }
        if (matched == 0)
            return 0;
        matched = 0;
    }

    return current_states -> is_final;
}
void DFA::minimize()
{
    // To be implemented
}
DFA::~DFA()
{
}

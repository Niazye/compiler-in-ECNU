import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Pattern;

public class CppMerger {
    // 修改正则表达式，正确匹配尖括号和双引号
    private static final Pattern INCLUDE_PATTERN = 
        Pattern.compile("^\\s*#include\\s+(?:\"([^\"]+)\"|<([^>]+)>)\\s*$");
    private static final Set<String> processedFiles = new HashSet<>();
    private static final Set<String> systemHeaders = new LinkedHashSet<>();
    private static final StringBuilder output = new StringBuilder();
    private static final Set<String> userDefinedHeaders = new HashSet<>();
    private static final Map<String, String> fileContents = new HashMap<>();
    private static boolean includeSystemHeaders = true;
    private static boolean removeSystemHeadersFromOutput = false;

    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in, "UTF-8");
        
        System.out.println("=== C++ 文件合并工具 ===");
        System.out.println("当前目录下的文件：");
        listCurrentDirectoryFiles();
        
        System.out.println("\n请输入要合并的文件名（用空格分隔，支持通配符*.cpp, *.h）：");
        System.out.print("> ");
        String input = scanner.nextLine();
        
        System.out.print("是否包含系统头文件（如<iostream>）？(y/n): ");
        includeSystemHeaders = scanner.nextLine().trim().equalsIgnoreCase("y");
        
        if (includeSystemHeaders) {
            System.out.print("是否从代码中移除系统头文件的#include语句？(y/n): ");
            removeSystemHeadersFromOutput = scanner.nextLine().trim().equalsIgnoreCase("y");
        }
        
        System.out.print("输出文件名（默认: merged.cpp）: ");
        String outputFile = scanner.nextLine().trim();
        if (outputFile.isEmpty()) {
            outputFile = "merged.cpp";
        }
        
        // 解析文件列表
        List<String> fileList = expandFileList(input.trim().split("\\s+"));
        
        if (fileList.isEmpty()) {
            System.out.println("没有找到匹配的文件！");
            return;
        }
        
        System.out.println("\n要合并的文件列表：");
        fileList.forEach(System.out::println);
        
        System.out.println("\n开始合并...");
        
        try {
            // 首先收集所有用户自定义头文件
            for (String fileName : fileList) {
                File file = new File(fileName);
                if (file.exists() && (fileName.endsWith(".h") || fileName.endsWith(".hpp"))) {
                    userDefinedHeaders.add(file.getCanonicalPath());
                }
            }
            
            // 处理每个文件
            for (String fileName : fileList) {
                File file = new File(fileName);
                if (file.exists()) {
                    processFile(file, 0);
                }
            }
            
            // 添加系统头文件
            if (includeSystemHeaders && !systemHeaders.isEmpty()) {
                output.insert(0, "// === 系统头文件 ===\n");
                for (String header : systemHeaders) {
                    output.insert(0, "#include " + header + "\n");
                }
                output.insert(0, "// === 合并的文件开始 ===\n\n");
            }
            
            // 添加文件头注释 - 使用英文或中文，但要确保编码正确
            String headerComment = String.format(
                "/*\n" +
                " * Generated by C++ Merger Tool\n" +
                " * Merge Time: %s\n" +
                " * Source Files: %s\n" +
                " * Total Files Merged: %d\n" +
                " */\n\n",
                new Date(),
                String.join(", ", fileList),
                processedFiles.size()
            );
            output.insert(0, headerComment);
            
            // 写入输出文件
            writeOutputFile(outputFile);
            
            System.out.printf("\n合并完成！已生成文件: %s\n", outputFile);
            System.out.printf("总文件数: %d\n", processedFiles.size());
            System.out.printf("系统头文件数: %d\n", systemHeaders.size());
            System.out.printf("输出文件大小: %.2f KB\n", new File(outputFile).length() / 1024.0);
            
        } catch (IOException e) {
            System.err.println("合并过程中出现错误: " + e.getMessage());
            e.printStackTrace();
        }
        
        scanner.close();
    }
    
    private static void listCurrentDirectoryFiles() {
        File currentDir = new File(".");
        File[] files = currentDir.listFiles((dir, name) -> 
            name.endsWith(".cpp") || name.endsWith(".h") || 
            name.endsWith(".cc") || name.endsWith(".hpp") ||
            name.endsWith(".c") || name.endsWith(".hh"));
        
        if (files != null) {
            Arrays.stream(files)
                  .sorted()
                  .forEach(f -> System.out.println("  " + f.getName()));
        }
    }
    
    private static List<String> expandFileList(String[] patterns) {
        List<String> result = new ArrayList<>();
        File currentDir = new File(".");
        
        for (String pattern : patterns) {
            if (pattern.contains("*")) {
                // 处理通配符
                String regex = pattern.replace(".", "\\.")
                                     .replace("*", ".*")
                                     .replace("?", ".");
                Pattern filePattern = Pattern.compile(regex);
                
                File[] files = currentDir.listFiles((dir, name) -> 
                    filePattern.matcher(name).matches());
                
                if (files != null) {
                    Arrays.stream(files)
                          .map(File::getName)
                          .forEach(result::add);
                }
            } else {
                // 直接文件名
                result.add(pattern);
            }
        }
        
        // 去重并排序（先.h/.hpp文件，后.cpp文件）
        return result.stream()
                     .distinct()
                     .sorted((a, b) -> {
                         boolean aIsHeader = a.matches(".*\\.(h|hpp|hh)$");
                         boolean bIsHeader = b.matches(".*\\.(h|hpp|hh)$");
                         if (aIsHeader && !bIsHeader) return -1;
                         if (!aIsHeader && bIsHeader) return 1;
                         return a.compareTo(b);
                     })
                     .toList();
    }
    
    private static void processFile(File file, int depth) throws IOException {
        String canonicalPath = file.getCanonicalPath();
        
        // 检查是否已经处理过
        if (processedFiles.contains(canonicalPath)) {
            return;
        }
        
        // 检查文件是否存在
        if (!file.exists()) {
            System.err.printf("警告: 文件 %s 不存在，跳过\n", file.getName());
            return;
        }
        
        // 检查递归深度（防止无限递归）
        if (depth > 50) {
            System.err.printf("警告: 文件 %s 包含深度过大，可能循环包含，跳过\n", file.getName());
            return;
        }
        
        // 标记为已处理
        processedFiles.add(canonicalPath);
        
        // 读取文件内容
        String content;
        if (fileContents.containsKey(canonicalPath)) {
            content = fileContents.get(canonicalPath);
        } else {
            content = readFileContent(file);
            fileContents.put(canonicalPath, content);
        }
        
        // 添加文件分隔注释
        output.append("\n").append("// ").append("=".repeat(60)).append("\n");
        output.append(String.format("// File: %s\n", file.getName()));
        output.append(String.format("// Path: %s\n", file.getPath()));
        output.append("// ").append("=".repeat(60)).append("\n\n");
        
        // 处理文件内容
        processFileContent(content, file.getParentFile(), depth + 1);
    }
    
    private static String readFileContent(File file) throws IOException {
        StringBuilder content = new StringBuilder();
        
        // 尝试自动检测文件编码
        String charset = detectCharset(file);
        
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(file), charset))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        }
        return content.toString();
    }
    
    private static String detectCharset(File file) throws IOException {
        // 简单检测UTF-8 BOM
        try (InputStream is = new FileInputStream(file)) {
            byte[] bom = new byte[3];
            int read = is.read(bom);
            if (read >= 3 && bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) {
                return "UTF-8";
            }
        }
        
        // 默认返回UTF-8，如果是GBK文件可能会导致问题
        // 可以尝试检测，但这里简单处理
        return "UTF-8";
    }
    
    private static void processFileContent(String content, File baseDir, int depth) throws IOException {
        String[] lines = content.split("\n");
        
        for (String line : lines) {
            java.util.regex.Matcher matcher = INCLUDE_PATTERN.matcher(line);
            
            if (matcher.matches()) {
                String userHeader = matcher.group(1);  // 双引号包含的头文件
                String systemHeader = matcher.group(2); // 尖括号包含的头文件
                
                if (systemHeader != null) {
                    // 系统头文件
                    if (includeSystemHeaders) {
                        systemHeaders.add("<" + systemHeader + ">");
                    }
                    
                    // 如果选择从输出中移除系统头文件，就不添加这行
                    if (!removeSystemHeadersFromOutput) {
                        output.append(line).append("\n");
                    }
                    continue;
                } else if (userHeader != null) {
                    // 用户头文件
                    File includedFile = null;
                    
                    // 1. 先在当前文件所在目录查找
                    if (baseDir != null) {
                        includedFile = new File(baseDir, userHeader);
                    }
                    
                    // 2. 如果没找到，在当前工作目录查找
                    if (includedFile == null || !includedFile.exists()) {
                        includedFile = new File(userHeader);
                    }
                    
                    if (includedFile.exists() && includedFile.isFile()) {
                        // 检查循环包含
                        String includedCanonicalPath;
                        try {
                            includedCanonicalPath = includedFile.getCanonicalPath();
                        } catch (IOException e) {
                            includedCanonicalPath = includedFile.getAbsolutePath();
                        }
                        
                        if (processedFiles.contains(includedCanonicalPath)) {
                            output.append("// [Already included] ").append(line).append("\n");
                            continue;
                        }
                        
                        // 递归处理包含的文件
                        output.append(String.format("// Include start: %s\n", userHeader));
                        processFile(includedFile, depth);
                        output.append(String.format("// Include end: %s\n", userHeader));
                    } else {
                        // 没找到文件，检查是否是标准C/C++库头文件
                        if (isStandardCppHeader(userHeader) || isStandardCHeader(userHeader)) {
                            // 如果是标准库头文件，按系统头文件处理
                            if (includeSystemHeaders) {
                                systemHeaders.add("<" + userHeader + ">");
                            }
                            if (!removeSystemHeadersFromOutput) {
                                output.append(line).append("\n");
                            }
                        } else {
                            // 没找到文件，保留原include语句并添加注释
                            output.append("// [Not found, kept as is] ").append(line).append("\n");
                        }
                    }
                }
            } else {
                // 普通代码行，直接添加
                output.append(line).append("\n");
            }
        }
    }
    
    // 检查是否是标准C++库头文件
    private static boolean isStandardCppHeader(String header) {
        String[] cppHeaders = {
            "iostream", "vector", "string", "map", "set", "unordered_map", 
            "unordered_set", "list", "deque", "queue", "stack", "array",
            "memory", "algorithm", "iterator", "functional", "numeric",
            "regex", "chrono", "thread", "mutex", "condition_variable",
            "atomic", "future", "random", "filesystem", "fstream",
            "sstream", "iomanip", "ios", "iosfwd", "istream", "ostream",
            "streambuf", "bitset", "complex", "exception", "stdexcept",
            "typeinfo", "type_traits", "utility", "tuple", "optional",
            "variant", "any", "charconv", "codecvt", "locale", "clocale",
            "cwchar", "cwctype", "cinttypes", "cstdint", "cstdio",
            "cstdlib", "cstring", "ctime", "cassert", "cerrno", "cfenv",
            "cfloat", "cstdarg", "cstddef", "cuchar", "cstdbool",
            "limits", "new", "typeindex", "ratio", "scoped_allocator",
            "shared_mutex", "system_error", "initializer_list",
            "valarray", "forward_list"
        };
        
        return Arrays.stream(cppHeaders).anyMatch(header::equals);
    }
    
    // 检查是否是标准C库头文件
    private static boolean isStandardCHeader(String header) {
        String[] cHeaders = {
            "stdio.h", "stdlib.h", "string.h", "time.h", "math.h", "assert.h",
            "ctype.h", "errno.h", "float.h", "limits.h", "locale.h", "signal.h",
            "stdarg.h", "stddef.h", "stdint.h", "stdbool.h", "wchar.h", "wctype.h",
            "tgmath.h", "fenv.h", "inttypes.h", "iso646.h", "setjmp.h", "uchar.h"
        };
        
        return Arrays.stream(cHeaders).anyMatch(header::equals) ||
               (header.startsWith("c") && header.length() > 1 && 
                Character.isLetter(header.charAt(1)));
    }
    
    private static void writeOutputFile(String outputFileName) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(
                new OutputStreamWriter(new FileOutputStream(outputFileName), StandardCharsets.UTF_8))) {
            writer.write(output.toString());
        }
    }
    
    // 可选：使用全部英文注释的版本
    private static void addHeaderCommentWithChinese() {
        String headerComment = String.format(
            "/*\n" +
            " * 合并文件生成时间: %s\n" +
            " * 原始文件: %s\n" +
            " * 共合并文件数: %d\n" +
            " */\n\n",
            new Date(),
            String.join(", ", processedFiles.stream()
                .map(f -> new File(f).getName())
                .toArray(String[]::new)),
            processedFiles.size()
        );
        output.insert(0, headerComment);
    }
}